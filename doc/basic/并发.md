#### 01 | 可见性、原子性和有序性问题：并发编程Bug的源头
1、缓存导致的可见性问题

一个线程对共享变量的修改，另一个线程能够立即看到，称为可见性

2、线程切换带来的原子性问题

我们把一个或多个操作在cpu执行的过程中不被中断的特性成为原子性

3、编译优化带来的有序性问题

只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发bug都是可以理解的、可以诊断的。

思考：
在32位机器上进行long型变量加减存在并发隐患
答：long占8个字节，先操作前32位，后操作后32位，不是原子性操作

所以java的8个基本类型中，long在32位机器上不保证原子性。


#### 02 | Java内存模型：看Java如何解决可见性和有序性问题

导致可见性的原因是缓存，导致有序性的原因是编译优化。

所以合理的解决发方案是 按需禁用缓存和编译优化。

jvm提供了按需禁用和编译优化的方法，包括``volatile、synchronized和final三个关键字，以及六项Happens-Before原则``

##### volatile

volatile关键字高速编译器，对这个遍历的读写，不使用cpu缓存，必须从内存中读取和写入

同时java1.5之后增强了volatile的一项Happen-Before规则

##### Happen-Before原则
前面一个操作的结果对后续操作是可见的。
